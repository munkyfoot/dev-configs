# --- simple, colored prompt with venv, git, SSH user@host when applicable ---
# Format: "%time [user@host] path git_branch[*] (venv) ❯"
# - Shows user@host only over SSH.
# - Appends "*" to git branch when the repo is dirty (staged or unstaged changes).
# - Always shows a green caret; color does not reflect exit status.
# Helpers
# Prints (venvname) when a Python virtualenv is active
prompt_venv() {
  [[ -n "$VIRTUAL_ENV" ]]       && echo "($(basename "$VIRTUAL_ENV"))"
}
# Prints the current git branch or tag; appends "*" if the working tree is dirty
prompt_git() {
  command -v git >/dev/null || return
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return
  local b dirty
  b=$(git symbolic-ref --quiet --short HEAD 2>/dev/null \
      || git describe --tags --exact-match 2>/dev/null \
      || git rev-parse --short HEAD 2>/dev/null) || return
  git diff --quiet --ignore-submodules --cached || dirty="*"
  git diff --quiet --ignore-submodules || dirty="*"
  echo "$b${dirty}"
}

# Show user@host only over SSH
SSH_PART=''
[[ -n "$SSH_CONNECTION" || -n "$SSH_TTY" ]] && SSH_PART='%n@%m'

# Left prompt: [SSH user@host] path git venv then green caret
autoload -Uz add-zsh-hook

# Recompute PROMPT before each command via precmd hook
build_prompt() {
	local -a segs
	segs+=('%F{244}%*%f')
	[[ -n $SSH_PART ]] && segs+=("$SSH_PART")
	segs+=('%F{blue}%1~%f')

	local git venv
	git="$(prompt_git)"; [[ -n $git ]] && segs+=("%F{cyan}${git}%f")
	venv="$(prompt_venv)"; [[ -n $venv ]] && segs+=("%F{magenta}${venv}%f")

	# Always show green caret regardless of last status
	PROMPT="${(j: :)segs} %F{green}❯%f "
}

add-zsh-hook precmd build_prompt

# Auto-refresh prompt every second (updates clock and catches external git changes)
TRAPALRM() {
  build_prompt
  zle reset-prompt 2>/dev/null
}

# Disable timer during command execution, re-enable when idle at prompt
_zsh_cmd_preexec() { unset TMOUT; }
_zsh_cmd_precmd()  { TMOUT=1; }
add-zsh-hook preexec _zsh_cmd_preexec
add-zsh-hook precmd _zsh_cmd_precmd
TMOUT=1
# --- end ---
